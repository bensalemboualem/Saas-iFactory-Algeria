"""
IAFactory Academy - FastAPI Main Application
"""
import logging
from collections import defaultdict
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import time
import asyncio

from app.core.config import settings
from app.core.database import engine, Base
from app.api import auth, users, courses, content, enrollments, payments, certificates  # rag, rag_advanced DISABLED

# Configure logging
logging.basicConfig(
    level=getattr(logging, settings.LOG_LEVEL),
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Application lifespan events.
    """
    # Startup
    logger.info("Starting IAFactory Academy API...")
    logger.info(f"Environment: {settings.ENVIRONMENT}")
    logger.info(f"Debug mode: {settings.DEBUG}")
    
    # Create tables (for development only - use Alembic in production)
    if settings.ENVIRONMENT == "development" and settings.DEBUG:
        logger.warning("Creating database tables (development mode)")
        Base.metadata.create_all(bind=engine)
    
    yield
    
    # Shutdown
    logger.info("Shutting down IAFactory Academy API...")


# Create FastAPI app
app = FastAPI(
    title=settings.APP_NAME,
    description="Learning Management System API",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    lifespan=lifespan,
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=settings.CORS_ALLOW_CREDENTIALS,
    allow_methods=settings.CORS_ALLOW_METHODS,
    allow_headers=settings.CORS_ALLOW_HEADERS,
)


# =============================================================================
# SECURITY: Rate Limiting Middleware
# =============================================================================

# In-memory rate limit storage (use Redis in production for multi-instance)
rate_limit_storage = defaultdict(lambda: {"count": 0, "reset_time": 0})
auth_rate_limit_storage = defaultdict(lambda: {"count": 0, "reset_time": 0, "lockout_until": 0})

# Sensitive endpoints that need stricter rate limiting
SENSITIVE_ENDPOINTS = {
    "/api/v1/auth/login": {"limit": 5, "window": 60, "lockout_after": 10, "lockout_duration": 300},
    "/api/v1/auth/register": {"limit": 3, "window": 60, "lockout_after": 5, "lockout_duration": 600},
    "/api/v1/auth/forgot-password": {"limit": 3, "window": 300, "lockout_after": 5, "lockout_duration": 900},
    "/api/v1/auth/reset-password": {"limit": 3, "window": 300, "lockout_after": 5, "lockout_duration": 900},
    "/api/v1/auth/resend-verification": {"limit": 2, "window": 300, "lockout_after": 5, "lockout_duration": 900},
}


def get_client_ip(request: Request) -> str:
    """Extract client IP from request, considering proxies."""
    forwarded = request.headers.get("X-Forwarded-For")
    if forwarded:
        return forwarded.split(",")[0].strip()
    return request.client.host if request.client else "unknown"


@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    """
    SECURITY: Rate limiting middleware with lockout for sensitive endpoints.

    - General endpoints: Configurable limit per minute
    - Auth endpoints: Stricter limits with account lockout
    """
    if not settings.RATE_LIMIT_ENABLED:
        return await call_next(request)

    client_ip = get_client_ip(request)
    current_time = time.time()
    path = request.url.path

    # Check if this is a sensitive endpoint
    if path in SENSITIVE_ENDPOINTS:
        config = SENSITIVE_ENDPOINTS[path]
        key = f"{client_ip}:{path}"
        storage = auth_rate_limit_storage[key]

        # Check if client is in lockout
        if storage["lockout_until"] > current_time:
            remaining = int(storage["lockout_until"] - current_time)
            return JSONResponse(
                status_code=429,
                content={
                    "detail": f"Too many failed attempts. Locked out for {remaining} seconds.",
                    "retry_after": remaining
                },
                headers={"Retry-After": str(remaining)}
            )

        # Reset window if expired
        if current_time > storage["reset_time"]:
            storage["count"] = 0
            storage["reset_time"] = current_time + config["window"]

        storage["count"] += 1

        # Check if should lockout
        if storage["count"] > config["lockout_after"]:
            storage["lockout_until"] = current_time + config["lockout_duration"]
            return JSONResponse(
                status_code=429,
                content={
                    "detail": f"Too many attempts. Account locked for {config['lockout_duration']} seconds.",
                    "retry_after": config["lockout_duration"]
                },
                headers={"Retry-After": str(config["lockout_duration"])}
            )

        # Check rate limit
        if storage["count"] > config["limit"]:
            retry_after = int(storage["reset_time"] - current_time)
            return JSONResponse(
                status_code=429,
                content={"detail": "Rate limit exceeded", "retry_after": retry_after},
                headers={"Retry-After": str(retry_after)}
            )

    else:
        # General rate limiting
        key = client_ip
        storage = rate_limit_storage[key]

        if current_time > storage["reset_time"]:
            storage["count"] = 0
            storage["reset_time"] = current_time + 60  # 1 minute window

        storage["count"] += 1

        if storage["count"] > settings.RATE_LIMIT_PER_MINUTE:
            retry_after = int(storage["reset_time"] - current_time)
            return JSONResponse(
                status_code=429,
                content={"detail": "Rate limit exceeded", "retry_after": retry_after},
                headers={"Retry-After": str(retry_after)}
            )

    return await call_next(request)


# Request timing middleware
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    """Add processing time to response headers."""
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response


# Exception handlers
@app.exception_handler(404)
async def not_found_handler(request: Request, exc):
    """Handle 404 errors."""
    return JSONResponse(
        status_code=404,
        content={"detail": "Resource not found"}
    )


@app.exception_handler(500)
async def internal_error_handler(request: Request, exc):
    """Handle 500 errors."""
    logger.error(f"Internal error: {exc}")
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error"}
    )


# Root endpoint
@app.get("/")
async def root():
    """Root endpoint with API info."""
    return {
        "name": settings.APP_NAME,
        "version": "1.0.0",
        "environment": settings.ENVIRONMENT,
        "docs": "/docs",
        "health": "/health"
    }


# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint for monitoring."""
    return {
        "status": "healthy",
        "environment": settings.ENVIRONMENT,
        "timestamp": time.time()
    }


# API routes
app.include_router(auth.router, prefix=f"{settings.API_PREFIX}/auth", tags=["Authentication"])
app.include_router(users.router, prefix=f"{settings.API_PREFIX}/users", tags=["Users"])
app.include_router(courses.router, prefix=f"{settings.API_PREFIX}/courses", tags=["Courses"])
app.include_router(content.router, prefix=f"{settings.API_PREFIX}/content", tags=["Content"])
app.include_router(enrollments.router, prefix=f"{settings.API_PREFIX}/enrollments", tags=["Enrollments"])
app.include_router(payments.router, prefix=f"{settings.API_PREFIX}/payments", tags=["Payments"])
app.include_router(certificates.router, prefix=f"{settings.API_PREFIX}/certificates", tags=["Certificates"])
# app.include_router(rag.router  # DISABLED TEMP, prefix=f"{settings.API_PREFIX}", tags=["RAG"])
# app.include_router(rag_advanced.router  # DISABLED TEMP, prefix=f"{settings.API_PREFIX}", tags=["RAG Advanced"])


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.RELOAD,
    )
